using Frends.HIT.LDAP.GetObjects.Definitions;
using System.ComponentModel;
using Novell.Directory.Ldap;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Linq;

namespace Frends.HIT.LDAP.GetObjects;

/// <summary>
/// LDAP task.
/// </summary>
public class LDAP
{
    /// <summary>
    /// Search objects from Active Directory.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.LDAP.SearchObjects)
    /// </summary>
    /// <param name="input">Input parameters.</param>
    /// <param name="connection">Connection parameters.</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this task.</param>
    /// <returns>Object { bool Success, string Error, string CommonName, List&lt;SearchResult&gt; SearchResult }</returns>
    public static Result SearchObjects([PropertyTab] Input input, [PropertyTab] Connection connection, CancellationToken cancellationToken)
    {
        if (string.IsNullOrWhiteSpace(connection.Host))
            throw new Exception("Host is missing.");

        if (string.IsNullOrEmpty(connection.User) && !connection.AnonymousBind)
            throw new Exception("Username is missing.");

        if (string.IsNullOrEmpty(connection.Password) && !connection.AnonymousBind)
            throw new Exception("Password is missing.");

        LdapConnectionOptions ldco = new LdapConnectionOptions();

        if (connection.IgnoreCertificates)
            ldco.ConfigureRemoteCertificateValidationCallback((sender, certificate, chain, errors) => true);

        LdapConnection conn = new LdapConnection(ldco);
        var defaultPort = connection.SecureSocketLayer ? 636 : 389;
        var atr = new List<string>();
        var searchResults = new List<SearchResult>();
        var searchConstraints = new LdapSearchConstraints(
                input.MsLimit,
                input.ServerTimeLimit,
                SetSearchDereference(input),
                input.MaxResults,
                false,
                input.BatchSize,
                null,
                0);

        if (input.Attributes != null)
            foreach (var i in input.Attributes)
                atr.Add(i.Key.ToString());

        // Default to v3 as it's the most commonly used version
        var ldapVersion = 3;
        switch (connection.LDAPProtocolVersion)
        {
            case LDAPVersion.V2:
                ldapVersion = 2;
                break;
            case LDAPVersion.V3:
                ldapVersion = 3;
                break;
            default:
                throw new ArgumentException($"Unsupported LDAP protocol version. {connection.LDAPProtocolVersion}");
        }

        try
        {
            conn.SecureSocketLayer = connection.SecureSocketLayer;
            conn.Connect(connection.Host, connection.Port == 0 ? defaultPort : connection.Port);
            if (connection.TLS)
                conn.StartTls();

            if (connection.AnonymousBind)
                conn.Bind(version: ldapVersion, dn: null, passwd: (string)null);
            else
                conn.Bind(version: ldapVersion, connection.User, connection.Password);

            LdapSearchQueue queue = conn.Search(
                input.SearchBase,
                SetScope(input),
                string.IsNullOrEmpty(input.Filter) ? null : input.Filter,
                atr.ToArray(),
                input.TypesOnly,
                null,
                searchConstraints);

            LdapMessage message;
            while ((message = queue.GetResponse()) != null)
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (message is LdapSearchResult ldapSearchResult)
                {
                    var entry = ldapSearchResult.Entry;
                    var attributeList = new List<AttributeSet>();
                    var getAttributeSet = entry.GetAttributeSet();
                    var ienum = getAttributeSet.GetEnumerator();

                    while (ienum.MoveNext())
                    {
                        LdapAttribute attribute = ienum.Current;
                        var attributeName = attribute.Name;
                        string attributeVal = null;

                        var attributeDefinition = input.Attributes != null
                            ? Array.Find(input.Attributes, d => d.Key.Equals(attributeName, StringComparison.OrdinalIgnoreCase))
                            : null;

                        if (attributeDefinition != null)
                        {
                            switch (attributeDefinition.ReturnType)
                            {
                                case AttributeReturnType.Byte:
                                    byte[] bytes = attribute.ByteValue;
                                    attributeVal = BitConverter.ToString(bytes).Replace("-", "");
                                    break;
                                case AttributeReturnType.Guid:
                                    byte[] guidBytes = attribute.ByteValue;
                                    Guid guid = new Guid(guidBytes);
                                    attributeVal = guid.ToString();
                                    break;
                                default:
                                    attributeVal = attribute.StringValue;
                                    break;
                            }
                        }
                        else
                        {
                            attributeVal = attribute.StringValue;
                        }


                        attributeList.Add(new AttributeSet { Key = attributeName, Value = attributeVal });
                    }


                    searchResults.Add(new SearchResult() { DistinguishedName = entry.Dn, AttributeSet = attributeList });
                }
            }
            return new Result(true, null, searchResults);
        }
        catch (LdapException ex)
        {
            if (connection.ThrowExceptionOnError)
                throw;
            return new Result(false, $"LdapException: {ex.Message}", null);
        }
        catch (Exception ex)
        {
            throw new Exception($"SearchObjects error: {ex}");
        }
        finally
        {
            if (connection.TLS) conn.StopTls();
            conn.Disconnect();
        }
    }

    internal static int SetScope(Input input)
    {
        return input.Scope switch
        {
            Scopes.ScopeBase => 0,
            Scopes.ScopeOne => 1,
            Scopes.ScopeSub => 2,
            _ => throw new Exception("SetScope error: Invalid scope."),
        };
    }

    internal static int SetSearchDereference(Input input)
    {
        return input.SearchDereference switch
        {
            SearchDereference.DerefNever => 0,
            SearchDereference.DerefSearching => 1,
            SearchDereference.DerefFinding => 2,
            SearchDereference.DerefAlways => 3,
            _ => throw new Exception("SetSearchConstraint error: Invalid search constraint."),
        };
    }
}
